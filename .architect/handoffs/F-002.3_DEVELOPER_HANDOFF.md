# Developer Handoff: F-002.3 AI-First Automated Onboarding

**Priority**: P0 - CRITICAL (This IS F-002, the killer feature)
**Effort**: 40-50 hours (~6 days)
**Specification**: `.architect/features/F-002.3_AI_FIRST_ONBOARDING.md`
**Pattern**: `.architect/patterns/AI_FIRST_VALIDATION_PATTERN.md`
**Philosophy**: `.architect/CORE_PHILOSOPHY.md`
**Status**: Ready for Implementation

---

## 🎯 What You're Building

**Transform onboarding from**:
```
20 minutes of user typing data
```

**To**:
```
50 seconds of user clicking "approve"
```

**The user types ONCE** (hotel name + city), then just validates what AI found.

---

## ⚠️ IMPORTANT: Read These First

**Before writing any code**, read:

1. **`.architect/CORE_PHILOSOPHY.md`** (10 min)
   - Understand the "AI does work, user validates" principle
   - This defines the entire product

2. **`.architect/patterns/AI_FIRST_VALIDATION_PATTERN.md`** (20 min)
   - The pattern you MUST follow
   - Code examples included

3. **`.architect/features/F-002.3_AI_FIRST_ONBOARDING.md`** (30 min)
   - Complete specification for this feature
   - UX flows, data sources, metrics

**Total reading**: 1 hour. **Do not skip this.**

---

## 📋 Implementation Phases

### Phase 1: Perplexity Integration (8-10 hours)

#### Task 1.1: Set Up Perplexity Client (2 hours)

**What to build**:
```python
# File: apps/ai_agent/services/perplexity_service.py

import os
import httpx
from typing import Dict, Optional

class PerplexityService:
    """
    Perplexity API integration for comprehensive hotel research.

    API Docs: https://docs.perplexity.ai/
    """

    def __init__(self):
        self.api_key = os.getenv('PERPLEXITY_API_KEY')
        if not self.api_key:
            logger.warning("PERPLEXITY_API_KEY not set. Auto-research disabled.")
            self.client = None
        else:
            self.base_url = "https://api.perplexity.ai"
            self.client = httpx.AsyncClient(
                base_url=self.base_url,
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                timeout=30.0
            )
```

**Steps**:
1. Create `perplexity_service.py`
2. Get Perplexity API key (already provided to you)
3. Add to `.env`: `PERPLEXITY_API_KEY=...`
4. Test connection with simple search

**Acceptance**:
- [ ] Import works
- [ ] Client initializes
- [ ] Can make test API call

#### Task 1.2: Implement Hotel Research (4 hours)

**What to build**:
```python
async def research_hotel(
    self,
    hotel_name: str,
    city: str,
    state: str = None
) -> Dict:
    """
    Comprehensive hotel research using Perplexity.

    Prompt Engineering Strategy:
    - Be very specific about what info we need
    - Ask for structured output
    - Include examples

    Returns:
        {
            "description": "Full hotel description...",
            "amenities": ["WiFi", "Pool", ...],
            "room_types": [
                {
                    "name": "Standard Queen",
                    "beds": "1 Queen",
                    "capacity": 2
                },
                ...
            ],
            "website": "https://...",
            "total_rooms": 17,
            "confidence": 0.85
        }
    """
    if not self.client:
        return {"error": "Perplexity not available"}

    # Build search query
    location = f"{city}, {state}" if state else city

    prompt = f"""
Research {hotel_name} in {location} and provide the following information:

1. A detailed 2-3 paragraph description of the hotel
2. Complete list of amenities (WiFi, pool, parking, etc.)
3. All room types with:
   - Room type name
   - Bed configuration (e.g., "1 Queen", "2 Twins")
   - Maximum capacity
4. Hotel website URL
5. Total number of rooms
6. Location details

Respond in this JSON format:
{{
  "description": "...",
  "amenities": ["...", "..."],
  "room_types": [
    {{"name": "...", "beds": "...", "capacity": 2}}
  ],
  "website": "https://...",
  "total_rooms": 17,
  "address": "..."
}}
"""

    try:
        response = await self.client.post(
            "/chat/completions",
            json={
                "model": "sonar-pro",  # Or whatever model you're using
                "messages": [
                    {
                        "role": "system",
                        "content": "You are a hotel research assistant. Provide accurate, factual information in JSON format."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.1,  # Low for factual
                "max_tokens": 2000
            }
        )

        data = response.json()
        result = json.loads(data['choices'][0]['message']['content'])
        result['confidence'] = 0.85  # Assign confidence based on quality

        logger.info(f"Perplexity research successful: {hotel_name}")
        return result

    except Exception as e:
        logger.error(f"Perplexity research failed: {str(e)}")
        return {"error": str(e)}
```

**Steps**:
1. Implement `research_hotel()` method
2. Craft effective prompt (trial and error)
3. Parse JSON response
4. Test with 5 real hotels

**Test Hotels**:
- Inn 32, Woodstock NH (from spec)
- Sunset Villa, Miami FL
- Mountain Lodge, Denver CO
- Coastal Inn, Seattle WA
- Downtown Hotel, Austin TX

**Acceptance**:
- [ ] Finds hotel description 90% of the time
- [ ] Finds amenities 85% of the time
- [ ] Finds room types 80% of the time
- [ ] Response time <5 seconds

#### Task 1.3: Add Error Handling & Logging (2 hours)

**What to add**:
```python
# Detailed logging
logger.info(f"Perplexity search: {hotel_name}, {city}")
logger.info(f"Found description: {len(result.get('description', ''))} chars")
logger.info(f"Found amenities: {len(result.get('amenities', []))}")
logger.info(f"Found room types: {len(result.get('room_types', []))}")

# Error handling
if not result.get('description'):
    logger.warning(f"No description found for {hotel_name}")

if not result.get('room_types'):
    logger.warning(f"No room types found for {hotel_name}")
```

**Acceptance**:
- [ ] All API calls logged
- [ ] Errors logged with context
- [ ] Graceful failure (returns partial data)

---

### Phase 2: Research Orchestrator (10-12 hours)

#### Task 2.1: Create Research Orchestrator (6 hours)

**What to build**:
```python
# File: apps/ai_agent/services/research_orchestrator.py

class ResearchOrchestrator:
    """
    Coordinates research across all sources.
    Core of the AI-First Validation Pattern.
    """

    def __init__(self):
        self.perplexity = PerplexityService()
        self.google_places = GooglePlacesService()
        self.scraper = DataExtractor()  # Existing

    async def research_hotel(
        self,
        hotel_name: str,
        city: str,
        state: str = None
    ) -> Dict:
        """
        Auto-discover ALL hotel data from multiple sources.

        Process:
        1. Launch all sources in parallel
        2. Merge results
        3. Apply defaults for gaps
        4. Return complete dataset with sources tracked
        """
        logger.info(f"Starting research for {hotel_name}, {city}")

        # Launch research in parallel
        results = await asyncio.gather(
            self.perplexity.research_hotel(hotel_name, city, state),
            self.google_places.search_hotel(hotel_name, city, state),
            return_exceptions=True
        )

        perplexity_data = results[0] if not isinstance(results[0], Exception) else {}
        places_data = results[1] if not isinstance(results[1], Exception) else {}

        # If Perplexity found website, scrape it
        website_data = {}
        website_url = perplexity_data.get('website')
        if website_url:
            logger.info(f"Scraping website: {website_url}")
            website_data = await self.scraper.extract_from_website(website_url)

        # Merge all sources
        merged = self._merge_data(perplexity_data, places_data, website_data)

        # Apply intelligent defaults
        complete = self._apply_defaults(merged, city, state)

        # Calculate confidence
        complete['_overall_confidence'] = self._calculate_confidence(complete)

        logger.info(f"Research complete. Confidence: {complete['_overall_confidence']}")

        return complete
```

**Steps**:
1. Create `research_orchestrator.py`
2. Implement parallel source calling
3. Test with 5 hotels
4. Verify all sources called correctly

**Acceptance**:
- [ ] Calls all sources in parallel
- [ ] Completes in <10 seconds
- [ ] Returns data even if one source fails

#### Task 2.2: Implement Data Merging (4 hours)

**What to build**:
```python
def _merge_data(
    self,
    perplexity: Dict,
    google_places: Dict,
    website: Dict
) -> Dict:
    """
    Merge data from multiple sources with intelligent conflict resolution.

    Priority:
    1. Government data (if available) - highest trust
    2. Google Places - verified business data
    3. Perplexity - comprehensive research
    4. Website - direct from source
    """
    merged = {}

    # Address: Prefer Google Places (most accurate)
    merged['address'] = self._choose_best(
        google_places.get('address'),
        perplexity.get('address'),
        website.get('address'),
        source_priority=['google_places', 'perplexity', 'website']
    )

    # Description: Prefer Perplexity (most comprehensive)
    merged['description'] = self._choose_best(
        perplexity.get('description'),
        website.get('description'),
        source_priority=['perplexity', 'website']
    )

    # Room types: Merge Perplexity + Website
    merged['room_types'] = self._merge_room_types(
        perplexity.get('room_types', []),
        website.get('room_types', [])
    )

    # Amenities: Combine from all sources (union)
    merged['amenities'] = list(set(
        perplexity.get('amenities', []) +
        website.get('amenities', [])
    ))

    # Photos: Prefer Google Places (higher quality)
    merged['photos'] = self._choose_best(
        google_places.get('photos'),
        website.get('photos'),
        source_priority=['google_places', 'website']
    )

    # GPS: Always from Google Places
    merged['latitude'] = google_places.get('location', {}).get('lat')
    merged['longitude'] = google_places.get('location', {}).get('lng')

    # Website URL: Prefer Perplexity
    merged['website'] = self._choose_best(
        perplexity.get('website'),
        google_places.get('website'),
        source_priority=['perplexity', 'google_places']
    )

    return merged
```

**Steps**:
1. Implement `_merge_data()` method
2. Implement `_choose_best()` helper
3. Implement `_merge_room_types()` helper
4. Test merging with real data

**Acceptance**:
- [ ] Chooses best source for each field
- [ ] Handles missing data gracefully
- [ ] Combines lists (amenities) intelligently

#### Task 2.3: Implement Intelligent Defaults (2 hours)

**What to build**:
```python
def _apply_defaults(self, data: Dict, city: str, state: str) -> Dict:
    """
    Fill gaps with intelligent defaults.
    """
    # Timezone from GPS (if we have it)
    if data.get('latitude') and not data.get('timezone'):
        data['timezone'] = self.google_places.infer_timezone_from_location(
            data['latitude'],
            data['longitude']
        )

    # Currency from state/country
    if not data.get('currency'):
        data['currency'] = 'USD'  # Default for US

    # Tax rate from state
    if not data.get('tax_rate') and state:
        tax_rates = {
            'FL': 13.0, 'CA': 10.5, 'NY': 14.8, 'NH': 9.0,
            # ... all 50 states
        }
        data['tax_rate'] = tax_rates.get(state.upper(), 10.0)

    # Check-in/out times (industry standard)
    if not data.get('check_in_time'):
        data['check_in_time'] = '3:00 PM'
        data['_check_in_source'] = 'industry_standard'

    if not data.get('check_out_time'):
        data['check_out_time'] = '11:00 AM'
        data['_check_out_source'] = 'industry_standard'

    # Cancellation policy (safe default)
    if not data.get('cancellation_policy'):
        data['cancellation_policy'] = '48 hours notice for full refund'
        data['_cancellation_source'] = 'industry_standard'

    return data
```

**Acceptance**:
- [ ] Fills all critical gaps
- [ ] Defaults are reasonable
- [ ] Tracks source for transparency

---

### Phase 3: Validation UI (8-10 hours)

#### Task 3.1: Create Validation Templates (4 hours)

Create these templates:

**File**: `apps/ai_agent/templates/ai_agent/partials/validate_location.html`
```html
<div class="validation-card">
  <div class="category-header">
    <span class="icon">📍</span>
    <h3>Location</h3>
  </div>

  <div class="findings">
    <div class="field">
      <strong>Address:</strong>
      <span>{{ data.address.value }}</span>
    </div>

    <div class="field">
      <strong>Timezone:</strong>
      <span>{{ data.timezone.value }}</span>
    </div>

    <div class="field">
      <strong>Currency:</strong>
      <span>{{ data.currency.value }}</span>
    </div>

    <div class="field">
      <strong>Tax Rate:</strong>
      <span>{{ data.tax_rate.value }}%</span>
    </div>
  </div>

  <div class="source-info">
    Source: {{ data._source }} ({{ data._confidence }}% confident)
  </div>

  <div class="actions">
    <button class="btn-approve" data-action="approve">
      APPROVE ✓
    </button>
    <button class="btn-edit" data-action="edit">
      EDIT
    </button>
  </div>
</div>
```

**Create similar templates for**:
- `validate_description.html`
- `validate_rooms.html`
- `validate_policies.html`
- `validate_photos.html`

**Acceptance**:
- [ ] All 5 category templates created
- [ ] Templates show AI findings clearly
- [ ] Source and confidence displayed
- [ ] Approve/Edit buttons work

#### Task 3.2: Implement Validation Actions (4 hours)

**File**: `apps/ai_agent/views.py` - Add new endpoint:
```python
@login_required
@require_http_methods(["POST"])
def validate_category(request):
    """
    Handle user validation of a category.

    Request:
        {
            "category": "location",
            "action": "approve" | "edit",
            "edits": {"field": "new_value", ...}  # If action=edit
        }

    Response:
        {
            "status": "ok",
            "next_category": "description" | "complete"
        }
    """
    data = json.loads(request.body)
    category = data['category']
    action = data['action']

    # Get agent
    agent = NoraAgent(request.user, get_organization(request.user))

    if action == 'approve':
        # Mark category as verified
        agent.context.task_state[f'{category}_verified'] = True
        agent.context.save()

        # Log approval for learning
        logger.info(f"User approved {category}")

        # Return next category
        next_cat = get_next_category(category)
        return JsonResponse({
            "status": "ok",
            "next_category": next_cat
        })

    elif action == 'edit':
        # Apply edits
        edits = data.get('edits', {})
        for field, value in edits.items():
            agent.context.task_state[field] = value

            # Log correction for learning
            logger.info(f"User edited {field}: {value}")

        agent.context.task_state[f'{category}_verified'] = True
        agent.context.save()

        next_cat = get_next_category(category)
        return JsonResponse({
            "status": "ok",
            "next_category": next_cat
        })
```

**Steps**:
1. Create `/api/validate-category/` endpoint
2. Implement approve logic
3. Implement edit logic
4. Test with frontend

**Acceptance**:
- [ ] Approve marks category as verified
- [ ] Edit saves changes
- [ ] Returns next category correctly

---

### Phase 4: Conversation Redesign (8-10 hours)

#### Task 4.1: Redesign NoraAgent Flow (6 hours)

**File**: `apps/ai_agent/services/nora_agent.py`

**Major changes**:

```python
async def process_message(self, user_message: str) -> Dict:
    """
    Process user message with AI-First pattern.
    """
    # Step 1: Get hotel name + city (ONLY input needed)
    if not self.context.task_state.get('hotel_name'):
        extracted = self._extract_hotel_identity(user_message)

        if extracted.get('hotel_name') and extracted.get('city'):
            # Got what we need! Start research
            self.context.task_state['hotel_name'] = extracted['hotel_name']
            self.context.task_state['city'] = extracted['city']
            self.context.task_state['state'] = extracted.get('state')
            self.context.save()

            # Trigger AI research
            return await self._start_auto_research()
        else:
            # Need more info
            return {
                "message": "I need your hotel name and city to get started. What are they?",
                "action": "collect_identity"
            }

    # Step 2: User is validating categories
    # (This is handled by validate_category endpoint now)

    return {"message": "Continuing onboarding..."}

async def _start_auto_research(self) -> Dict:
    """
    Start automatic research with all sources.
    """
    hotel_name = self.context.task_state['hotel_name']
    city = self.context.task_state['city']
    state = self.context.task_state.get('state')

    # Create orchestrator
    orchestrator = ResearchOrchestrator()

    # Show progress to user
    progress_message = f"🔍 Researching {hotel_name}...\n\n"
    progress_message += "✓ Searching Google Places...\n"
    progress_message += "✓ Researching on Perplexity...\n"

    # Do research
    complete_data = await orchestrator.research_hotel(hotel_name, city, state)

    # Store in context
    self.context.task_state['_research_data'] = complete_data
    self.context.save()

    # Return first validation screen (location)
    return {
        "message": "Research complete! Let's validate what I found.",
        "action": "show_validation",
        "category": "location",
        "data": complete_data
    }
```

**Steps**:
1. Rewrite `process_message()` for new flow
2. Implement `_start_auto_research()`
3. Remove old Q&A logic
4. Test end-to-end

**Acceptance**:
- [ ] User only types name + city
- [ ] Research triggers automatically
- [ ] Validation screens appear
- [ ] Data flows correctly

#### Task 4.2: Add Progress UI (2 hours)

**File**: `apps/ai_agent/templates/ai_agent/partials/research_progress.html`

```html
<div class="research-progress">
  <h3>🔍 Researching {{ hotel_name }}...</h3>

  <div class="progress-items">
    <div class="item done">
      ✓ Searching Google Places (0.8s)
    </div>
    <div class="item done">
      ✓ Researching on Perplexity (2.3s)
    </div>
    <div class="item done">
      ✓ Website found, scraping (1.2s)
    </div>
    <div class="item active">
      ⏳ Downloading photos...
    </div>
    <div class="item pending">
      ○ Finalizing data...
    </div>
  </div>

  <div class="overall-progress">
    <div class="bar" style="width: 80%"></div>
  </div>
</div>
```

**Acceptance**:
- [ ] Shows real-time progress
- [ ] Animates nicely
- [ ] Shows completion

---

### Phase 5: Testing & Polish (6-8 hours)

#### Task 5.1: End-to-End Testing (4 hours)

**Test with these REAL hotels**:

1. **Inn 32, Woodstock NH** (from spec)
2. **Ace Hotel, New York NY**
3. **The Standard, Los Angeles CA**
4. **Kimpton, San Francisco CA**
5. **Boutique hotel of your choice**

**For each hotel, measure**:
- Time to complete
- Automation rate (% of fields found)
- Accuracy (% correct)
- Approval rate (% user clicked approve vs edit)

**Acceptance**:
- [ ] 5/5 hotels complete successfully
- [ ] Average time <60 seconds
- [ ] Automation rate >80%
- [ ] Approval rate >80%

#### Task 5.2: Edge Case Testing (2 hours)

**Test these scenarios**:

1. **Hotel not found anywhere**
   - Should fallback gracefully to manual Q&A

2. **Partial data only**
   - Should show what was found, ask for rest

3. **Perplexity API down**
   - Should still work with Google Places only

4. **All sources fail**
   - Should fallback to full manual onboarding

**Acceptance**:
- [ ] All fallbacks work
- [ ] No crashes
- [ ] User always completes

#### Task 5.3: Polish & Bug Fixes (2 hours)

- Fix any bugs found
- Polish UI animations
- Improve error messages
- Add helpful tooltips

---

## ✅ Definition of Done

Before marking F-002.3 complete:

**Functionality**:
- [ ] User types hotel name + city only
- [ ] AI researches 4+ sources automatically
- [ ] User validates findings (approve/edit)
- [ ] Hotel created with 90%+ data auto-discovered
- [ ] Fallback to manual works gracefully

**Metrics**:
- [ ] Average onboarding time <60 seconds
- [ ] Automation rate >80%
- [ ] Approval rate >80%
- [ ] Accuracy >90%
- [ ] Works for 90% of test hotels

**Quality**:
- [ ] No P0 bugs
- [ ] Tested with 20+ real hotels
- [ ] Code reviewed by architect
- [ ] Documentation updated
- [ ] All code committed

---

## 📊 How to Measure Success

### During Development:

Log these metrics:
```python
logger.info(f"Onboarding metrics:")
logger.info(f"  - Time: {time_seconds}s")
logger.info(f"  - Automation: {fields_found}/{total_fields} = {automation_pct}%")
logger.info(f"  - Approvals: {approvals}/{categories} = {approval_pct}%")
logger.info(f"  - Accuracy: {correct}/{total} = {accuracy_pct}%")
```

### Target Metrics:

| Metric | Target |
|--------|--------|
| Time to complete | <60s |
| Automation rate | >80% |
| Approval rate | >80% |
| Accuracy | >90% |
| Completion rate | >95% |

---

## 🆘 Getting Unstuck

**If Perplexity API not working**:
- Check API key
- Check endpoint URL
- Try simple test query first
- Ask architect for help

**If data merging is hard**:
- Start simple (just choose first source)
- Add conflict resolution later
- Log everything to understand data

**If accuracy is low**:
- Improve Perplexity prompt
- Adjust confidence thresholds
- Ask architect to review

**Stuck for >2 hours?** → Ask architect immediately

---

## 🎯 This is THE Priority

**F-002.3 blocks**:
- F-003 (needs hotel data)
- All downstream features
- Product launch

**This is the killer feature. Make it great.**

---

**Ready? Start with Phase 1, Task 1.1. Go! 🚀**
