# F-001.1: Multi-Tenancy Isolation & Organization Model

**Feature ID**: F-001.1
**Parent Feature**: F-001 (Stayfull PMS Core)
**Type**: Architecture Enhancement (Production Blocker)
**Priority**: P0 - Critical
**Status**: Approved - Ready for Development
**Effort**: 10 hours
**Created**: 2025-10-23
**Decision**: #008

---

## üéØ Executive Summary

**Problem**: F-001 lacks proper multi-tenancy isolation. Hotels can see other hotels' data in Admin and API. Guest records are globally shared without organization boundary. This creates data leakage risks when deploying to multiple hotel owners.

**Solution**: Introduce `Organization` model as the tenant boundary. All hotels, guests, and staff belong to an organization. Implement row-level security in Admin and API to enforce data isolation.

**Impact**: Enables production deployment with multiple hotel owners on the same platform while maintaining strict data privacy.

**Discovered During**: UAT Scenario 3 - User correctly identified that Room could be assigned to RoomType from different hotel, raising concerns about comprehensive data fencing.

---

## üìã Business Requirements

### Current State (F-001):
```
System Architecture: Single-tenant mindset
- All hotels share same namespace
- All guests are globally unique by email
- Admin shows ALL data to ALL staff users
- API returns ALL data (filtered by hotel FK, but not by user's hotel)
- Works for: Single hotel owner with multiple properties
- Fails for: Multiple independent hotel owners on same platform
```

### Target State (F-001.1):
```
System Architecture: Multi-tenant (organization-based)
- Organizations are the tenant boundary
- Hotels belong to organizations
- Guests belong to organizations (email unique within org)
- Staff belong to organizations
- Admin shows ONLY user's organization data
- API returns ONLY user's organization data
- Works for: Multiple hotel owners, chains, independent hotels
```

### Use Cases Enabled:

**Use Case 1: Hotel Chain**
```
Organization: "Seaside Hotel Group"
‚îú‚îÄ Hotel 1: Seaside Resort Miami
‚îú‚îÄ Hotel 2: Seaside Resort LA
‚îî‚îÄ Hotel 3: Seaside Resort NYC

Staff User: manager@seaside.com
  ‚Üí Can see: All 3 hotels, all guests across properties
  ‚Üí Cannot see: Any other organization's data
```

**Use Case 2: Independent Hotels on Same Platform**
```
Organization A: "Downtown Inn" (Owner: John Smith)
‚îú‚îÄ Hotel: Downtown Inn Portland
‚îî‚îÄ Guests: 150 guests

Organization B: "Mountain Lodge" (Owner: Jane Doe)
‚îú‚îÄ Hotel: Mountain Lodge Aspen
‚îî‚îÄ Guests: 200 guests

Staff from Org A CANNOT see Org B data (complete isolation)
```

**Use Case 3: Platform Admin**
```
User: Platform Superuser (is_superuser=True)
  ‚Üí Can see: ALL organizations, ALL hotels, ALL data
  ‚Üí Purpose: Platform management, support, debugging
```

---

## üèóÔ∏è Technical Specification

### 1. New Model: Organization

**File**: `apps/core/models.py`

```python
class Organization(BaseModel):
    """
    Represents a hotel owner/operator entity (tenant boundary).

    All hotels, guests, and staff belong to an organization.
    This is the primary isolation boundary in the system.

    Examples:
    - Independent hotel: "Downtown Inn"
    - Hotel chain: "Marriott International"
    - Hotel group: "Smith Hospitality Group"
    """

    # Basic Info
    name = models.CharField(
        max_length=200,
        help_text="Organization name (e.g., 'Smith Hotel Group')"
    )
    slug = models.SlugField(
        max_length=200,
        unique=True,
        help_text="URL-safe identifier (globally unique)"
    )

    # Type
    type = models.CharField(
        max_length=20,
        choices=[
            ('independent', 'Independent Hotel'),
            ('chain', 'Hotel Chain/Group'),
            ('franchise', 'Franchise Group'),
        ],
        default='independent',
        help_text="Organization type"
    )

    # Contact (for billing/support)
    contact_email = models.EmailField(
        help_text="Primary contact email for this organization"
    )
    contact_phone = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        help_text="Primary contact phone"
    )

    # Status
    is_active = models.BooleanField(
        default=True,
        help_text="Organization active status"
    )

    # Settings
    settings = models.JSONField(
        blank=True,
        null=True,
        help_text="Organization-level settings and preferences"
    )

    class Meta:
        ordering = ['name']
        verbose_name = 'Organization'
        verbose_name_plural = 'Organizations'
        indexes = [
            models.Index(fields=['slug']),
            models.Index(fields=['is_active']),
        ]

    def __str__(self):
        return self.name

    def clean(self):
        """Validate model fields"""
        super().clean()

        # Validate type
        valid_types = [choice[0] for choice in self._meta.get_field('type').choices]
        if self.type not in valid_types:
            raise ValidationError({
                'type': f'Type must be one of: {", ".join(valid_types)}'
            })
```

**Rationale**: Organization is the "tenant" in our multi-tenant architecture. Every hotel owner gets an Organization, and all their data lives within that boundary.

---

### 2. Model Updates: Add Organization FK

**File**: `apps/hotels/models.py`

```python
class Hotel(BaseModel):
    # NEW: Organization relationship (REQUIRED)
    organization = models.ForeignKey(
        'core.Organization',
        on_delete=models.PROTECT,
        related_name='hotels',
        help_text="Parent organization that owns this hotel"
    )

    # ... rest of existing fields unchanged
```

**File**: `apps/guests/models.py`

```python
class Guest(BaseModel):
    # NEW: Organization relationship (REQUIRED)
    organization = models.ForeignKey(
        'core.Organization',
        on_delete=models.PROTECT,
        related_name='guests',
        help_text="Organization this guest belongs to"
    )

    # Email is now unique WITHIN organization (not globally)
    email = models.EmailField(
        help_text="Guest email address (unique within organization)"
    )

    # ... rest of existing fields unchanged

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Guest'
        verbose_name_plural = 'Guests'
        # NEW: Email unique within organization
        unique_together = [['organization', 'email']]
        indexes = [
            models.Index(fields=['organization', 'email']),
            models.Index(fields=['organization', 'loyalty_tier']),
        ]
```

**File**: `apps/staff/models.py`

```python
class Staff(BaseModel):
    # NEW: Organization relationship (REQUIRED)
    organization = models.ForeignKey(
        'core.Organization',
        on_delete=models.PROTECT,
        related_name='staff',
        help_text="Organization this staff member belongs to"
    )

    # User now unique WITHIN organization
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='staff',
        help_text="Django user account (unique within organization)"
    )

    # Hotel is OPTIONAL (staff can be org-level)
    hotel = models.ForeignKey(
        'hotels.Hotel',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='staff',
        help_text="Specific hotel (optional, null = org-level staff)"
    )

    # ... rest of existing fields unchanged

    class Meta:
        ordering = ['organization', 'hotel', 'user__last_name']
        verbose_name = 'Staff'
        verbose_name_plural = 'Staff'
        # Email can exist across orgs, but not within same org
        unique_together = [['organization', 'user']]
```

**Important**: Reservation and Room models DON'T need organization FK because they inherit it through hotel FK.

---

### 3. Admin Row-Level Security

**File**: `apps/core/admin.py`

```python
from django.contrib import admin
from django.db.models import Q


class OrganizationFilteredAdmin(admin.ModelAdmin):
    """
    Base admin class that filters all querysets by user's organization.

    Filtering Rules:
    1. Superusers (is_superuser=True) see ALL data across ALL organizations
    2. Staff users see ONLY their organization's data
    3. Users without staff association see NOTHING

    All hotel-related admin classes MUST inherit from this.
    """

    def get_queryset(self, request):
        """Filter queryset by user's organization"""
        qs = super().get_queryset(request)

        # Rule 1: Superusers see everything (platform admins)
        if request.user.is_superuser:
            return qs

        # Rule 2: Hotel staff see only their organization's data
        if hasattr(request.user, 'staff') and request.user.staff:
            organization = request.user.staff.organization

            # Direct organization FK
            if hasattr(self.model, 'organization'):
                return qs.filter(organization=organization)

            # Indirect through hotel (e.g., RoomType, Room, Reservation)
            elif hasattr(self.model, 'hotel'):
                return qs.filter(hotel__organization=organization)

            # Guest through reservations
            elif self.model.__name__ == 'Guest':
                return qs.filter(organization=organization)

            # Fallback: no filtering possible
            else:
                return qs

        # Rule 3: No staff association = no access
        return qs.none()

    def formfield_for_foreignkey(self, db_field, request, **kwargs):
        """Filter foreign key dropdowns by user's organization"""

        # Skip filtering for superusers
        if request.user.is_superuser:
            return super().formfield_for_foreignkey(db_field, request, **kwargs)

        # Filter if user has staff association
        if hasattr(request.user, 'staff') and request.user.staff:
            organization = request.user.staff.organization

            # Filter Hotel dropdown
            if db_field.name == 'hotel':
                kwargs['queryset'] = db_field.related_model.objects.filter(
                    organization=organization
                )

            # Filter RoomType dropdown
            elif db_field.name == 'room_type':
                kwargs['queryset'] = db_field.related_model.objects.filter(
                    hotel__organization=organization
                )

            # Filter Guest dropdown
            elif db_field.name == 'guest':
                kwargs['queryset'] = db_field.related_model.objects.filter(
                    organization=organization
                )

        return super().formfield_for_foreignkey(db_field, request, **kwargs)

    def has_view_permission(self, request, obj=None):
        """Check if user can view this object"""
        if not obj:
            return super().has_view_permission(request, obj)

        # Superusers can view everything
        if request.user.is_superuser:
            return True

        # Check organization match
        if hasattr(request.user, 'staff') and request.user.staff:
            user_org = request.user.staff.organization

            if hasattr(obj, 'organization'):
                return obj.organization == user_org
            elif hasattr(obj, 'hotel'):
                return obj.hotel.organization == user_org

        return False

    def has_change_permission(self, request, obj=None):
        """Check if user can edit this object"""
        return self.has_view_permission(request, obj)

    def has_delete_permission(self, request, obj=None):
        """Check if user can delete this object"""
        return self.has_view_permission(request, obj)
```

**Apply to all admins**:

```python
# apps/hotels/admin.py
@admin.register(Hotel)
class HotelAdmin(OrganizationFilteredAdmin, DynamicArrayMixin, admin.ModelAdmin):
    # ... existing config

@admin.register(RoomType)
class RoomTypeAdmin(OrganizationFilteredAdmin, DynamicArrayMixin, admin.ModelAdmin):
    # ... existing config

@admin.register(Room)
class RoomAdmin(OrganizationFilteredAdmin, admin.ModelAdmin):
    # ... existing config


# apps/guests/admin.py
@admin.register(Guest)
class GuestAdmin(OrganizationFilteredAdmin, admin.ModelAdmin):
    # ... existing config


# apps/reservations/admin.py
@admin.register(Reservation)
class ReservationAdmin(OrganizationFilteredAdmin, DynamicArrayMixin, admin.ModelAdmin):
    # ... existing config


# apps/staff/admin.py
@admin.register(Staff)
class StaffAdmin(OrganizationFilteredAdmin, admin.ModelAdmin):
    # ... existing config
```

---

### 4. API Permissions & Filtering

**File**: `apps/core/permissions.py` (NEW)

```python
from rest_framework import permissions


class IsOrganizationMemberOrReadOnly(permissions.BasePermission):
    """
    Permission class for organization-based access control.

    Rules:
    1. Superusers: Full access to everything
    2. Staff users: Can view/edit ONLY their organization's data
    3. Authenticated users: Read-only to public data (if any)
    4. Anonymous users: No access
    """

    def has_permission(self, request, view):
        """Check if user has permission to access this endpoint"""

        # Superusers have full access
        if request.user and request.user.is_superuser:
            return True

        # Staff users have access to their org
        if request.user and request.user.is_authenticated:
            if hasattr(request.user, 'staff') and request.user.staff:
                return True

        # Read-only for safe methods (if we want public API later)
        if request.method in permissions.SAFE_METHODS:
            return True

        return False

    def has_object_permission(self, request, view, obj):
        """Check if user can access this specific object"""

        # Superusers can access everything
        if request.user and request.user.is_superuser:
            return True

        # Staff can only access their organization's data
        if request.user and hasattr(request.user, 'staff') and request.user.staff:
            user_org = request.user.staff.organization

            # Direct organization FK
            if hasattr(obj, 'organization'):
                return obj.organization == user_org

            # Indirect through hotel
            elif hasattr(obj, 'hotel'):
                return obj.hotel.organization == user_org

        return False


class IsSameOrganization(permissions.BasePermission):
    """
    Strict permission: User MUST be from same organization.
    Use for sensitive operations.
    """

    def has_object_permission(self, request, view, obj):
        if request.user.is_superuser:
            return True

        if hasattr(request.user, 'staff') and request.user.staff:
            user_org = request.user.staff.organization

            if hasattr(obj, 'organization'):
                return obj.organization == user_org
            elif hasattr(obj, 'hotel'):
                return obj.hotel.organization == user_org

        return False
```

**Update ViewSets**:

```python
# apps/hotels/views.py
from apps.core.permissions import IsOrganizationMemberOrReadOnly


class HotelViewSet(viewsets.ModelViewSet):
    queryset = Hotel.objects.all()
    serializer_class = HotelSerializer
    permission_classes = [IsOrganizationMemberOrReadOnly]

    def get_queryset(self):
        """Filter hotels by user's organization"""
        qs = super().get_queryset()

        # Superusers see all
        if self.request.user.is_superuser:
            return qs

        # Staff see only their organization's hotels
        if hasattr(self.request.user, 'staff') and self.request.user.staff:
            return qs.filter(organization=self.request.user.staff.organization)

        # Others see nothing
        return qs.none()

    def perform_create(self, serializer):
        """Auto-assign organization when creating hotel"""
        if hasattr(self.request.user, 'staff') and self.request.user.staff:
            serializer.save(organization=self.request.user.staff.organization)
        else:
            serializer.save()


# Repeat for all viewsets: RoomType, Room, Guest, Reservation, Staff
```

---

### 5. Data Migration

**File**: `apps/core/migrations/0002_add_organization.py`

```python
from django.db import migrations, models
import django.db.models.deletion


def create_default_organization(apps, schema_editor):
    """
    Create a default organization and assign all existing data to it.
    This ensures backward compatibility with existing deployments.
    """
    Organization = apps.get_model('core', 'Organization')
    Hotel = apps.get_model('hotels', 'Hotel')
    Guest = apps.get_model('guests', 'Guest')
    Staff = apps.get_model('staff', 'Staff')

    # Create default organization
    default_org, created = Organization.objects.get_or_create(
        slug='default',
        defaults={
            'name': 'Default Organization',
            'type': 'independent',
            'contact_email': 'admin@example.com',
            'is_active': True,
        }
    )

    if created:
        print(f"Created default organization: {default_org.name}")

    # Assign all existing hotels to default org
    hotels_count = Hotel.objects.filter(organization__isnull=True).update(
        organization=default_org
    )
    print(f"Assigned {hotels_count} hotels to default organization")

    # Assign all existing guests to default org
    guests_count = Guest.objects.filter(organization__isnull=True).update(
        organization=default_org
    )
    print(f"Assigned {guests_count} guests to default organization")

    # Assign all existing staff to default org
    staff_count = Staff.objects.filter(organization__isnull=True).update(
        organization=default_org
    )
    print(f"Assigned {staff_count} staff to default organization")


class Migration(migrations.Migration):

    dependencies = [
        ('core', '0001_initial'),
        ('hotels', '0001_initial'),
        ('guests', '0002_alter_guest_id_document_number'),
        ('staff', '0001_initial'),
    ]

    operations = [
        # Create Organization model
        migrations.CreateModel(
            name='Organization',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('name', models.CharField(help_text="Organization name (e.g., 'Smith Hotel Group')", max_length=200)),
                ('slug', models.SlugField(help_text='URL-safe identifier (globally unique)', max_length=200, unique=True)),
                ('type', models.CharField(choices=[('independent', 'Independent Hotel'), ('chain', 'Hotel Chain/Group'), ('franchise', 'Franchise Group')], default='independent', help_text='Organization type', max_length=20)),
                ('contact_email', models.EmailField(help_text='Primary contact email for this organization', max_length=254)),
                ('contact_phone', models.CharField(blank=True, help_text='Primary contact phone', max_length=20, null=True)),
                ('is_active', models.BooleanField(default=True, help_text='Organization active status')),
                ('settings', models.JSONField(blank=True, help_text='Organization-level settings and preferences', null=True)),
            ],
            options={
                'verbose_name': 'Organization',
                'verbose_name_plural': 'Organizations',
                'ordering': ['name'],
            },
        ),

        # Add indexes
        migrations.AddIndex(
            model_name='organization',
            index=models.Index(fields=['slug'], name='core_organi_slug_idx'),
        ),
        migrations.AddIndex(
            model_name='organization',
            index=models.Index(fields=['is_active'], name='core_organi_is_acti_idx'),
        ),

        # Run data migration
        migrations.RunPython(create_default_organization, reverse_code=migrations.RunPython.noop),
    ]
```

**Additional migrations for each app to add organization FK** (generated by makemigrations).

---

### 6. Organization Admin

**File**: `apps/core/admin.py`

```python
from django.contrib import admin
from .models import Organization


@admin.register(Organization)
class OrganizationAdmin(admin.ModelAdmin):
    """Admin interface for Organization model"""

    list_display = ['name', 'slug', 'type', 'contact_email', 'hotel_count', 'is_active', 'created_at']
    list_filter = ['type', 'is_active', 'created_at']
    search_fields = ['name', 'slug', 'contact_email']
    readonly_fields = ['id', 'created_at', 'updated_at']

    fieldsets = (
        ('Basic Information', {'fields': ('name', 'slug', 'type')}),
        ('Contact', {'fields': ('contact_email', 'contact_phone')}),
        ('Status & Settings', {'fields': ('is_active', 'settings')}),
        ('Metadata', {'fields': ('id', 'created_at', 'updated_at'), 'classes': ('collapse',)}),
    )

    def hotel_count(self, obj):
        """Display number of hotels in this organization"""
        return obj.hotels.count()
    hotel_count.short_description = 'Hotels'

    def get_queryset(self, request):
        """Optimize queryset"""
        qs = super().get_queryset(request)

        # Non-superusers only see their own organization
        if not request.user.is_superuser:
            if hasattr(request.user, 'staff') and request.user.staff:
                return qs.filter(id=request.user.staff.organization_id)
            return qs.none()

        return qs
```

---

### 7. Testing Requirements

**New Test Files**:

1. `apps/core/tests/test_organization_model.py` - Organization model tests
2. `apps/core/tests/test_multi_tenancy.py` - Multi-tenancy isolation tests
3. Update all existing tests to include organization

**Key Tests to Write**:

```python
# Test organization isolation in models
def test_guest_email_unique_within_organization():
    """Same email can exist in different organizations"""
    org1 = Organization.objects.create(name="Org 1", slug="org1")
    org2 = Organization.objects.create(name="Org 2", slug="org2")

    # Same email in different orgs - should work
    guest1 = Guest.objects.create(organization=org1, email="john@email.com")
    guest2 = Guest.objects.create(organization=org2, email="john@email.com")

    assert guest1.email == guest2.email
    assert guest1.organization != guest2.organization


# Test admin filtering
def test_staff_user_only_sees_own_organization_hotels():
    """Staff users should only see hotels from their organization"""
    org1 = Organization.objects.create(name="Org 1", slug="org1")
    org2 = Organization.objects.create(name="Org 2", slug="org2")

    hotel1 = Hotel.objects.create(organization=org1, name="Hotel 1")
    hotel2 = Hotel.objects.create(organization=org2, name="Hotel 2")

    user = User.objects.create_user(username="staff1")
    staff = Staff.objects.create(user=user, organization=org1)

    # Simulate admin request
    request = MockRequest(user=user)
    admin = HotelAdmin(Hotel, admin.site)
    qs = admin.get_queryset(request)

    assert hotel1 in qs
    assert hotel2 not in qs


# Test API filtering
def test_api_filters_by_organization():
    """API should only return data from user's organization"""
    # Similar test for API endpoints
    pass
```

**Test Coverage Target**: 95%+ including all multi-tenancy scenarios

---

## üìä Implementation Steps

### Phase 1: Models (3 hours)
1. Create Organization model in apps/core/models.py
2. Add organization FK to Hotel, Guest, Staff models
3. Update Guest unique constraint (organization + email)
4. Create migrations
5. Write model tests (15+ tests)
6. Run tests - ensure all pass

### Phase 2: Admin (3 hours)
7. Create OrganizationFilteredAdmin mixin
8. Update all 6 admin classes to inherit from mixin
9. Create OrganizationAdmin
10. Test admin filtering manually
11. Write admin tests
12. Run tests - ensure all pass

### Phase 3: API (2 hours)
13. Create permission classes
14. Update all 6 viewsets with permissions
15. Add get_queryset() filtering to all viewsets
16. Write API tests
17. Run tests - ensure all pass

### Phase 4: Data Migration (1 hour)
18. Run makemigrations
19. Create data migration for default organization
20. Test migration on local database
21. Verify all existing data assigned to default org

### Phase 5: Integration Testing (1 hour)
22. Create test organizations
23. Create test hotels in different orgs
24. Create test staff users
25. Verify complete isolation in Admin
26. Verify complete isolation in API
27. Run full test suite (target: 165+ tests, all passing)

---

## ‚úÖ Definition of Done

- [ ] Organization model created and tested
- [ ] All models have organization FK
- [ ] Guest email unique within organization (not globally)
- [ ] OrganizationFilteredAdmin mixin created
- [ ] All 6 admin classes inherit from mixin
- [ ] Admin filtering tested (staff sees only their org)
- [ ] Permission classes created
- [ ] All 6 viewsets have org filtering
- [ ] API filtering tested (returns only user's org data)
- [ ] Migrations created and tested
- [ ] Default organization migration works
- [ ] All existing tests updated and passing
- [ ] 15+ new tests for multi-tenancy
- [ ] Test coverage ‚â• 95%
- [ ] Documentation updated
- [ ] Deployed to Railway
- [ ] UAT resumed and validated

---

## üéØ Success Criteria

**Functional**:
- ‚úÖ Superuser can see ALL organizations
- ‚úÖ Staff user can ONLY see their organization
- ‚úÖ Same guest email can exist in different organizations
- ‚úÖ Hotel from Org A cannot select RoomType from Org B
- ‚úÖ API returns only user's organization data

**Technical**:
- ‚úÖ 165+ tests passing (151 existing + 15 new)
- ‚úÖ 95%+ code coverage
- ‚úÖ No breaking changes to existing functionality
- ‚úÖ Migration runs successfully on production

**Business**:
- ‚úÖ Platform ready for multi-hotel deployment
- ‚úÖ Data isolation verified
- ‚úÖ F-001 is truly production-ready

---

## üìù Notes

**Why Organization, not HotelGroup?**
- "Organization" is more flexible terminology
- Covers independent hotels, chains, and franchises
- Industry-standard term in SaaS platforms

**Why Guest belongs to Organization?**
- Enables loyalty programs across hotel properties
- Single guest profile for better UX
- Still maintains isolation between competing hotels

**Why not Subdomain-based multi-tenancy?**
- Organization-based is more flexible
- Easier to manage
- Works with API keys
- Can add subdomain routing later if needed

**Migration Risk**:
- Low - all existing data goes to "default" organization
- No data loss
- Backward compatible
- Can assign to proper orgs after deployment

---

## üöÄ Ready for Development

This specification is complete and ready for developer implementation.

**Estimated Effort**: 10 hours
**Estimated Tests**: +15 tests (165 total)
**Target Coverage**: 95%+
**Risk**: Low (clean addition, minimal breaking changes)

**Architect Approval**: ‚úÖ APPROVED
**User Approval**: ‚úÖ APPROVED (Option 1 chosen)

---

**Next**: Create developer handoff document with step-by-step implementation guide.
